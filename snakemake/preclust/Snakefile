"""
    snakemake --keep-going -j 999999 --cluster "sbatch --exclude={cluster.exclude} -c {cluster.ntasks} -N {cluster.Nodes}  -t {cluster.runtime} -J {cluster.jobname} --mail-type={cluster.mail_type} --mail-user={cluster.mail}" --cluster-config cluster.json --configfile experimental_experiments.json --latency-wait 100 --verbose -n
    snakemake --keep-going -j 999999 --cluster "sbatch --exclude={cluster.exclude} -c {cluster.ntasks} -N {cluster.Nodes}  -t {cluster.runtime} -J {cluster.jobname} --mail-type={cluster.mail_type} --mail-user={cluster.mail}" --cluster-config cluster.json --configfile experimental_experiments.json --latency-wait 100 --verbose --forcerun linclust_sim linclust_real v_measure_sim v_measure_real evaluation_sim evaluation -n --reason
    snakemake  --configfile experimental_experiments.json --latency-wait 100 --verbose -n
    snakemake --configfile experimental_experiments.json --latency-wait 100 --verbose --rerun-incomplete quality -n 
    snakemake --rulegraph --configfile experiments.json | dot -Tpng > figures/ruledag.png


    # preprocessing
    1. bax to bam
    2. subreads to ccs, to merged ccs
    3. ccs to demultiplexed ccs w/o barcodes (lima)

    # simulation
    4. Simlord
    5. adding of tags with "add_read_tags_to_bam.py"
    
    # algorithms
    3. demultiplexed ccs to isoseq3 cluster
    3'. (1) demultiplexed ccs (w. q values) and (2) the accessions of the flnc ccs reads produced by isoseq3 cluster to qt-clust (check if seqs have been altered!)

    # evaluation
    4. alignment of reads to hg38 (skip this if simulated data)
    5. Fix cluster-files produced by cluster and qt-clust to a unified format
    6. Run "compute_cluster_quality.py" and get various metrics

    # structure
    indata: 
    root folder: /nfs/brubeck.bx.psu.edu/scratch6/ksahlin/preclust_eval/
    bam_folder, ccs_folder, lima_folder, 
    isoseq3_folder, simlord_folder
    flnc_fastq_folder


    # target rules:
    preprocess 
    simulation
    cluster
    evaluation

"""

shell.prefix("set -o pipefail; ")
# configfile: "experiments.json"

####################################################
########## standard python functions ###############
####################################################

import re
import os
import errno
import shutil

def mkdir_p(path):
    print("creating", path)
    try:
        os.makedirs(path)
    except OSError as exc:  # Python >2.5
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else:
            raise

def parse_gnu_time(stderr_file):
    lines = open(stderr_file, 'r').readlines()
    print(lines)
    for l in lines:
        usertime_match =  re.search('User time \(seconds\): [\d.]+', l)
        wct_match = re.search('Elapsed \(wall clock\) time \(h:mm:ss or m:ss\): [\d.:]+', l) 
        mem_match = re.search('Maximum resident set size \(kbytes\): [\d.:]+', l) 
        if usertime_match:
            usertime = float(usertime_match.group().split(':')[1].strip())
        if wct_match:
            wallclocktime = wct_match.group().split()[7]
        if mem_match:
            mem_tmp = int(mem_match.group().split()[5])
            memory_gb = mem_tmp / 4000000.0 

    vals = list(map(lambda x: float(x), wallclocktime.split(":") ))
    if len(vals) == 3:
        h,m,s = vals
        tot_wallclock_secs = h*3600.0 + m*60.0 + s
    elif len(vals) == 2:
        m,s = vals
        tot_wallclock_secs = m*60.0 + s

    return usertime, tot_wallclock_secs, memory_gb


def read_fasta(fasta_file):
    fasta_seqs = {}
    k = 0
    temp = ''
    accession = ''
    for line in fasta_file:
        if line[0] == '>' and k == 0:
            accession = line[1:].strip().split()[0]
            fasta_seqs[accession] = ''
            k += 1
        elif line[0] == '>':
            yield accession, temp
            temp = ''
            accession = line[1:].strip().split()[0]
        else:
            temp += line.strip()
    if accession:
        yield accession, temp


def clean_dir(folder):
    keep_files = set(["final_candidates.fa", "cluster_report.csv", "cluster_summary.txt", "logfile.txt", "final_candidates_lq.fa"]) 
    for the_file in os.listdir(folder):
        if the_file in keep_files:
            continue

        file_path = os.path.join(folder, the_file)
        try:
            if os.path.isfile(file_path):
                os.unlink(file_path)
            elif os.path.isdir(file_path): 
                shutil.rmtree(file_path)
        except Exception as e:
            print(e)
#######################################


wildcard_constraints:
    dataset="[^/]+",
    ont_dataset="[^/]+",
    sim_dataset="[^/]+",
    nr_reads="[^/]+"

############## TARGET FILES ####################

# PREPROCESS
TARGET_FILES = {}

def subreads_files(datasets):
    files = []
    for dataset in datasets:
        for movie in config[dataset]["movies"]:
            files.append(config["DATA"] + "{0}/subreads/{1}.subreads.bam".format(dataset, movie))
    return files


def ccs_files(datasets):
    files = []
    for dataset in datasets:
        for movie in config[dataset]["movies"]:
            files.append(config["DATA"] + "{0}/ccs/{1}.ccs.bam".format(dataset, movie))
    return files

def lima_files(datasets):
    files = []
    for dataset in datasets:
        for movie in config[dataset]["movies"]:
            files.append(config["DATA"] + "{0}/lima/{1}.demux.primer_5p--primer_3p.bam".format(dataset, movie))
    return files

# subreads_files = lambda dataset: expand(config["DATA"] + "{dataset}/subreads/{movie}.subreads.bam", dataset = dataset, movie = config[dataset]["movies"] )
# ccs_files = lambda wildcards: expand(config["DATA"] + "{dataset}/ccs/{movie}.ccs.bam", dataset = config["DATASET"], movie = config[wildcards.dataset]["movies"] )
# lima_files = lambda wildcards: expand(config["DATA"] + "{dataset}/lima/{movie}.lima.bam", dataset = config["DATASET"], movie = config[wildcards.dataset]["movies"])


TARGET_FILES['preprocess'] = subreads_files(config["ISOSEQ_DATASET"]) + ccs_files(config["ISOSEQ_DATASET"]) + lima_files(config["ISOSEQ_DATASET"])


#CLUSTER

isoseq3_isoseq_files = expand(config["ROOT_OUT"] + "cluster/isoseq3/{dataset}/unpolished.{suffix}", dataset = config["ISOSEQ_DATASET"], suffix = ["bam", "cluster", "flnc.bam"]) 
# qt_qlust_files =
TARGET_FILES["cluster"] = isoseq3_isoseq_files 

isoseq3_sim_files = expand(config["ROOT_OUT"] + "cluster/isoseq3/{sim_dataset}/{nr_reads}/unpolished.{suffix}", sim_dataset = config["SIM_DATASET"], nr_reads =config["NR_SIM_READS"], suffix = ["bam", "cluster", "flnc.bam"]) 
TARGET_FILES["cluster_sim"] = isoseq3_sim_files


#EVALUATION
eval_isoseq_files = expand(config["ROOT_OUT"] + "evaluation/{dataset}/{tool}_table.tsv", dataset = config["ISOSEQ_DATASET"], tool = ["isoseq3", "qt_clust", "carnac_lr", "linclust"]) 
TARGET_FILES["evaluation"] = eval_isoseq_files

#EVALUATION SIMULATED
eval_sim_files = expand(config["ROOT_OUT"] + "evaluation/{sim_dataset}/{nr_reads}/{tool}_table.tsv", sim_dataset = config["SIM_DATASET"],  nr_reads = config["NR_SIM_READS"], tool = ["isoseq3", "qt_clust", "carnac_lr", "linclust"]) 
TARGET_FILES["evaluation_sim"] = eval_sim_files

# EVALUATION ONT
eval_ont_files = expand(config["ROOT_OUT"] + "evaluation/{ont_dataset}/ont/{tool}_table.tsv", ont_dataset = config["ONT_DATASET"], tool = ["qt_clust", "carnac_lr", "linclust"]) 
TARGET_FILES["evaluation_ont"] = eval_ont_files

#EVALUATION NR CORES
evaluation_nr_cores_files = expand(config["ROOT_OUT"] + "evaluation_nr_cores/{dataset}/{nr_cores}/{tool}_table.tsv", dataset = config["ISOSEQ_DATASET"], tool = ["qt_clust"], nr_cores = config["NR_CORES"]) 
TARGET_FILES["evaluation_nr_cores"] = evaluation_nr_cores_files


# SIMULATE
simulate_files = expand(config["ROOT_OUT"] + "ccs/{sim_dataset}/{nr_reads}/ccs.bam" , sim_dataset = config["SIM_DATASET"], nr_reads =config["NR_SIM_READS"]) 
TARGET_FILES["simulation"] = simulate_files 

#PLOTS
plot1_pb_file = expand(config["ROOT_OUT"] + "evaluation/{dataset}/V_per_class_size.pdf", dataset = config["ISOSEQ_DATASET"], tool = ["qt_clust"]) 
plot1_ont_file = expand(config["ROOT_OUT"] + "evaluation/{dataset}/ont/V_per_class_size.pdf", dataset = config["ONT_DATASET"], tool = ["qt_clust"]) 
plot1_sim_file = expand(config["ROOT_OUT"] + "evaluation/{dataset}/{nr_reads}/V_per_class_size.pdf", dataset = config["SIM_DATASET"], tool = ["qt_clust"], nr_reads =config["NR_SIM_READS"]) 
TARGET_FILES["evaluation"] = plot1_pb_file + plot1_ont_file + plot1_sim_file



rule all:
    input: config["ROOT_OUT"] + "evaluation/all_datasets_eval_table.tsv"
#     input:  TARGET_FILES["preprocess"], TARGET_FILES["simulation"], TARGET_FILES["cluster"], TARGET_FILES["evaluation"]

rule preprocess:
        input: TARGET_FILES["preprocess"]

# rule simulation:
#         input: TARGET_FILES["simulation"]

rule cluster:
        input: TARGET_FILES["cluster"]

rule cluster_sim:
        input: TARGET_FILES["cluster_sim"]

rule evaluation:
        input: TARGET_FILES["evaluation"]

rule evaluation_sim:
        input: TARGET_FILES["evaluation_sim"]

rule evaluation_ont:
        input: TARGET_FILES["evaluation_ont"]

rule evaluation_nr_cores:
        input: TARGET_FILES["evaluation_nr_cores"]

rule simulation:
        input: TARGET_FILES["simulation"]

rule plots:
        input: TARGET_FILES["plots"]

#####################################################

rule bax2bam:
        input: #hdf5_files = config["RAW_DATA"] + "{batch_size}/{movie,*bax.h5}"
        output: bam_subreads = config["DATA"] + "{dataset}/subreads/{movie}.subreads.bam",
                bam_index = config["DATA"] + "{dataset}/subreads/{movie}.subreads.bam.pbi"
        run:
            pass
            # shell("bax2bam  $raw_path$movie\_s1_p0.1.bax.h5 $raw_path$movie\_s1_p0.2.bax.h5 $raw_path$movie\_s1_p0.3.bax.h5 -o {wildcards.dataset}/subreads/{wildcards.movie} ")


rule ccs:
    input: bam_subreads = rules.bax2bam.output.bam_subreads
    output: ccs_bam = config["DATA"] + "{dataset}/ccs/{movie}.ccs.bam",
            bam_index = config["DATA"] + "{dataset}/ccs/{movie}.ccs.bam.pbi",
    run:
        shell("ccs --minPasses=1 --numThreads=64 --polish {input.bam_subreads} {output.ccs_bam} ")


rule lima:
    input: ccs_reads = rules.ccs.output.ccs_bam, 
            primers = config["DATA"] + "{dataset}/primers.fasta"
    output: demultiplexed_ccs_reads = config["DATA"] + "{dataset}/lima/{movie}.demux.primer_5p--primer_3p.bam" 
    run:
        shell("source activate isoseq3")
        out = config["DATA"] + "{0}/lima/{1}.demux.bam".format(wildcards.dataset, wildcards.movie)
        shell("lima {input.ccs_reads} {input.primers} {out} --isoseq --no-pbi --dump-clips")


rule merge_demultiplexed_files:
    input: infiles = lambda wildcards: expand(rules.lima.output.demultiplexed_ccs_reads, dataset = wildcards.dataset, movie = config[wildcards.dataset]["movies"]) 
    output: outfile = config["ROOT_OUT"] + "ccs/{dataset}/ccs.bam" 
    
    run:
        shell("samtools merge {output.outfile} {input.infiles}")
        shell("pbindex {output.outfile}")


rule isoseq3_real:
    input:  ccs = rules.merge_demultiplexed_files.output.outfile
    output: time_and_mem = config["ROOT_OUT"] + "time_and_mem/isoseq3/{dataset}/runtime.stdout",
            clusters = config["ROOT_OUT"] + "cluster/isoseq3/{dataset}/unpolished.cluster",
            flnc = config["ROOT_OUT"] + "cluster/isoseq3/{dataset}/unpolished.flnc.bam",
            consensus = config["ROOT_OUT"] + "cluster/isoseq3/{dataset}/unpolished.bam",
            fasta_flattened_out = config["ROOT_OUT"] + "cluster/isoseq3/{dataset}/unpolished_flattened.flnc.fasta"
    run:
        shell("source activate isoseq3")
        time = config["GNUTIME"]
        mkdir_p(config["ROOT_OUT"] + "time_and_mem/isoseq3/{0}/".format(wildcards.dataset) )
        mkdir_p(config["ROOT_OUT"] + "cluster/isoseq3/{0}/".format(wildcards.dataset) )
        shell("{time} isoseq3 cluster --num-threads 8 {input.ccs} {output.consensus} --verbose 2>&1 | tee {output.time_and_mem} ")

        fasta_out = config["ROOT_OUT"] + "cluster/isoseq3/{0}/unpolished.flnc.fasta".format(wildcards.dataset)
        flnc_in = config["ROOT_OUT"] + "cluster/isoseq3/{0}/unpolished.flnc.bam".format(wildcards.dataset)
        shell("bamtools convert -format fasta -in {flnc_in} -out {fasta_out} ")
        
        fasta_flattened_out = config["ROOT_OUT"] + "cluster/isoseq3/{0}/unpolished_flattened.flnc.fasta".format(wildcards.dataset)
        shell("python /galaxy/home/ksahlin/local_python_modules/bin/flatten_fasta.py {fasta_out} {fasta_flattened_out}")

rule qt_clust_real:
    input:  flnc = rules.isoseq3_real.output.flnc,
            ccs = rules.merge_demultiplexed_files.output.outfile
    output: time_and_mem = config["ROOT_OUT"] + "time_and_mem/qt_clust/{dataset}/runtime.stdout",
            clusters = config["ROOT_OUT"] + "cluster/qt_clust/{dataset}/pre_clusters.csv"
    run:
        time = config["GNUTIME"]
        mkdir_p(config["ROOT_OUT"] + "time_and_mem/qt_clust/{0}/".format(wildcards.dataset) )
        outfolder = config["ROOT_OUT"] + "cluster/qt_clust/{0}/".format(wildcards.dataset)

        mkdir_p(outfolder)
        # python qt_qlust.py --flnc ~/tmp/simlord_simulated_ensembl_coding_seqs_chr22_w_extra_tags.fastq.bam --ccs ~/tmp/simlord_simulated_ensembl_coding_seqs_chr22_w_extra_tags.fastq.bam --outfolder ~/tmp/qt_clust_chr22_100k/ --t 4
        # time python  preclust3.py  --reads ~/Documents/data/iso-Seq/alzheimer/isoseq_flnc_300k.fastq  --outfolder ~/tmp/precluster3/alz_400kreads_debug_time_t4 --t 4
        shell("{time} python /galaxy/home/ksahlin/prefix/source/isocon_nontargeted/modules/qt_clust/qt_clust.py --t 1 --flnc {input.flnc} --ccs {input.ccs}  --outfolder {outfolder}  2>&1 | tee {output.time_and_mem}")

rule carnac_real:
    input:  flnc_fasta = rules.isoseq3_real.output.fasta_flattened_out,
    output: time_and_mem_carnac = config["ROOT_OUT"] + "time_and_mem/carnac_lr/{dataset}/runtime_carnac.stdout",
            # time_and_mem_minimap = config["ROOT_OUT"] + "time_and_mem/carnac_lr/{dataset}/runtime_minimap.stdout",
            clusters = config["ROOT_OUT"] + "cluster/carnac_lr/{dataset}/clusters.csv"
    run:

        if wildcards.dataset == "Alzheimer_IsoSeq_2016":
            shell("touch {output.clusters}")
            shell("touch {output.time_and_mem_carnac}")

        else:
            time = config["GNUTIME"]        
            mkdir_p(config["ROOT_OUT"] + "time_and_mem/carnac_lr/{0}/".format(wildcards.dataset) )
            outfolder = config["ROOT_OUT"] + "cluster/carnac_lr/{0}/".format(wildcards.dataset)
            mkdir_p(outfolder)
            
            minimap_out = config["ROOT_OUT"] + "cluster/carnac_lr/{0}/minimap2.paf".format(wildcards.dataset)
            time_and_mem_minimap = config["ROOT_OUT"] + "time_and_mem/carnac_lr/{0}/runtime_minimap.stdout".format(wildcards.dataset)
            shell("{time} minimap -Sw2 -L100 -t8 {input.flnc_fasta} {input.flnc_fasta} > {minimap_out} 2> {time_and_mem_minimap}")
            # shell("{time} minimap2 -t 8 -X {input.flnc_fasta} {input.flnc_fasta} > {minimap_out} 2> {time_and_mem_minimap}")

            carnac_input = config["ROOT_OUT"] + "cluster/carnac_lr/{0}/carnac_in.txt​".format(wildcards.dataset)
            shell("python /galaxy/home/ksahlin/prefix/source/CARNAC/scripts/paf_to_CARNAC.py {minimap_out} {input.flnc_fasta}  {carnac_input}")

            carnac_output = config["ROOT_OUT"] + "cluster/carnac_lr/{0}/carnac_out.txt​".format(wildcards.dataset)        
            shell("{time} CARNAC-LR -f {carnac_input} -t 8 -o {carnac_output} 2> {output.time_and_mem_carnac}")

            script_path = config["SCRIPT_FOLDER"]        
            shell("python {script_path}/carnac_modify_clusterformat.py --carnacfile {carnac_output} --flnc {input.flnc_fasta} --outfile {output.clusters} ")



rule linclust_real:
    input:  flnc_fasta = rules.isoseq3_real.output.fasta_flattened_out,
    output: time_and_mem_linclust = config["ROOT_OUT"] + "time_and_mem/linclust/{dataset}/runtime_linclust.stdout",
            clusters = config["ROOT_OUT"] + "cluster/linclust/{dataset}/clusters.tsv"
    run:
        time = config["GNUTIME"]
        
        mkdir_p(config["ROOT_OUT"] + "time_and_mem/linclust/{0}/".format(wildcards.dataset) )
        outfolder = config["ROOT_OUT"] + "cluster/linclust/{0}/".format(wildcards.dataset)
        mkdir_p(outfolder)

        linclust_output = config["ROOT_OUT"] + "cluster/linclust/{0}/linclust_out.txt".format(wildcards.dataset)
        tmp_dir = config["ROOT_OUT"] + "cluster/linclust/{0}/linclust_tmpdir​".format(wildcards.dataset)
        shell("{time} mmseqs easy-linclust --seq-id-mode 1 --cov-mode 1 --threads 8 {input.flnc_fasta} {linclust_output} {tmp_dir} 2> {output.time_and_mem_linclust}")

        script_path = config["SCRIPT_FOLDER"]        
        shell("python {script_path}/modify_cluster_format_linclust.py {linclust_output}_cluster.tsv {output.clusters} ")



rule simulate_dataset:
    input: 
        refs  = "/nfs/brubeck.bx.psu.edu/scratch6/ksahlin/data/ENSEMBLE_simulated/ensembl_coding_seqs.fa",
        sample_readlengths  = "/nfs/brubeck.bx.psu.edu/scratch6/ksahlin/preclust_eval/cluster/isoseq3/RC0_1cell_2017/unpolished.flnc.fastq",
        # qt_clust_predicted = rules.qt_clust.output.clusters
    output: 
        reads = config["ROOT_OUT"] + "ccs/{sim_dataset}/{nr_reads}/ccs.bam",
        fastq = config["ROOT_OUT"] + "ccs/{sim_dataset}/{nr_reads}/ccs.fastq",
        index = config["ROOT_OUT"] + "ccs/{sim_dataset}/{nr_reads}/ccs.bam.pbi"
    run:
        shell("source activate simlord")
        shell("which python")
        shell("python --version")
        shell("pip list")
        # refs = "/nfs/brubeck.bx.psu.edu/scratch6/ksahlin/data/ENSEMBLE_simulated/ensembl_coding_seqs.fa"
        # sample_readlengths = "/nfs/brubeck.bx.psu.edu/scratch6/ksahlin/preclust_eval/cluster/isoseq3/RC0_1cell_2017/unpolished.flnc.fastq"
        intermediate_reads = config["ROOT_OUT"] + "ccs/{0}/{1}/ccs".format(wildcards.sim_dataset, wildcards.nr_reads)
        shell("simlord --uniform-chromosome-probability --read-reference {input.refs} --sample-readlength-from-fastq {input.sample_readlengths}  -n {wildcards.nr_reads}  {intermediate_reads}")

        intermediate_bam = config["ROOT_OUT"] + "ccs/{0}/{1}/ccs_tmp.bam".format(wildcards.sim_dataset, wildcards.nr_reads)
        shell("samtools view -b {intermediate_reads}.fastq.sam > {intermediate_bam}")
        script_path = config["SCRIPT_FOLDER"] 


        shell("python {script_path}/add_read_tags_to_bam.py --inbam {intermediate_bam}  --outbam {output.reads}")
        shell("pbindex {output.reads}")


rule isoseq3_sim:
    input:  ccs = rules.simulate_dataset.output.reads
    output: time_and_mem = config["ROOT_OUT"] + "time_and_mem/isoseq3/{sim_dataset}/{nr_reads}/runtime.stdout",
            clusters = config["ROOT_OUT"] + "cluster/isoseq3/{sim_dataset}/{nr_reads}/unpolished.cluster",
            flnc = config["ROOT_OUT"] + "cluster/isoseq3/{sim_dataset}/{nr_reads}/unpolished.flnc.bam",
            consensus = config["ROOT_OUT"] + "cluster/isoseq3/{sim_dataset}/{nr_reads}/unpolished.bam"
    run:
        # shell("source activate isoseq3")
        time = config["GNUTIME"]
        mkdir_p(config["ROOT_OUT"] + "time_and_mem/isoseq3/{0}_{1}/".format(wildcards.sim_dataset, wildcards.nr_reads) )
        mkdir_p(config["ROOT_OUT"] + "cluster/isoseq3/{0}_{1}/".format(wildcards.sim_dataset, wildcards.nr_reads) )
        shell("{time} isoseq3 cluster --num-threads 8 {input.ccs} {output.consensus} --verbose 2>&1 | tee {output.time_and_mem} ")



rule qt_clust_sim:
    input:  flnc = rules.simulate_dataset.output.reads,
            ccs = rules.simulate_dataset.output.reads
    output: time_and_mem = config["ROOT_OUT"] + "time_and_mem/qt_clust/{sim_dataset}/{nr_reads}/runtime.stdout",
            clusters = config["ROOT_OUT"] + "cluster/qt_clust/{sim_dataset}/{nr_reads}/pre_clusters.csv"
    run:
        time = config["GNUTIME"]
        mkdir_p(config["ROOT_OUT"] + "time_and_mem/qt_clust/{0}/{1}/".format(wildcards.sim_dataset, wildcards.nr_reads) )
        outfolder = config["ROOT_OUT"] + "cluster/qt_clust/{0}/{1}/".format(wildcards.sim_dataset, wildcards.nr_reads)

        mkdir_p(outfolder)
        # python qt_qlust.py --flnc ~/tmp/simlord_simulated_ensembl_coding_seqs_chr22_w_extra_tags.fastq.bam --ccs ~/tmp/simlord_simulated_ensembl_coding_seqs_chr22_w_extra_tags.fastq.bam --outfolder ~/tmp/qt_clust_chr22_100k/ --t 4
        # time python  preclust3.py  --reads ~/Documents/data/iso-Seq/alzheimer/isoseq_flnc_300k.fastq  --outfolder ~/tmp/precluster3/alz_400kreads_debug_time_t4 --t 4
        shell("{time} python /galaxy/home/ksahlin/prefix/source/isocon_nontargeted/modules/qt_clust/qt_clust.py --t 1 --flnc {input.flnc} --ccs {input.ccs}  --outfolder {outfolder}  2>&1 | tee {output.time_and_mem}")


rule carnac_sim:
    input:  flnc = rules.simulate_dataset.output.fastq,
    output: time_and_mem_carnac = config["ROOT_OUT"] + "time_and_mem/carnac_lr/{sim_dataset}/{nr_reads}/runtime_carnac.stdout",
            # time_and_mem_minimap = config["ROOT_OUT"] + "time_and_mem/carnac_lr/{sim_dataset}/{nr_reads}/runtime_minimap.stdout",
            clusters = config["ROOT_OUT"] + "cluster/carnac_lr/{sim_dataset}/{nr_reads}/clusters.csv"
    run:
        time = config["GNUTIME"]
        mkdir_p(config["ROOT_OUT"] + "time_and_mem/carnac_lr/{0}/{1}/".format(wildcards.sim_dataset, wildcards.nr_reads) )
        outfolder = config["ROOT_OUT"] + "cluster/carnac_lr/{0}/{1}/".format(wildcards.sim_dataset, wildcards.nr_reads)
        mkdir_p(outfolder)
        
        minimap_out = config["ROOT_OUT"] + "cluster/carnac_lr/{0}/{1}/minimap2.paf".format(wildcards.sim_dataset, wildcards.nr_reads)
        time_and_mem_minimap = config["ROOT_OUT"] + "time_and_mem/carnac_lr/{0}/{1}/runtime_minimap.stdout".format(wildcards.sim_dataset, wildcards.nr_reads)

        shell("{time} minimap2 -t 8 -X {input.flnc} {input.flnc} > {minimap_out} 2> {time_and_mem_minimap}")

        carnac_input = config["ROOT_OUT"] + "cluster/carnac_lr/{0}/{1}/carnac_in.txt​".format(wildcards.sim_dataset, wildcards.nr_reads)
        shell("python /galaxy/home/ksahlin/prefix/source/CARNAC/scripts/paf_to_CARNAC.py {minimap_out} {input.flnc}  {carnac_input}")

        carnac_output = config["ROOT_OUT"] + "cluster/carnac_lr/{0}/{1}/carnac_out.txt​".format(wildcards.sim_dataset, wildcards.nr_reads)        
        shell("{time} CARNAC-LR -f {carnac_input} -t 8 -o {carnac_output} 2> {output.time_and_mem_carnac}")
    
        script_path = config["SCRIPT_FOLDER"]        
        shell("python {script_path}/carnac_modify_clusterformat.py --carnacfile {carnac_output} --flnc {input.flnc} --outfile {output.clusters} ")


rule linclust_sim:
    input:  flnc = config["ROOT_OUT"] + "ccs/{sim_dataset}/{nr_reads}/ccs.fasta",
    output: time_and_mem_linclust = config["ROOT_OUT"] + "time_and_mem/linclust/{sim_dataset}/{nr_reads}/runtime_linclust.stdout",
            clusters = config["ROOT_OUT"] + "cluster/linclust/{sim_dataset}/{nr_reads}/clusters.tsv"
    run:
        time = config["GNUTIME"]
        
        mkdir_p(config["ROOT_OUT"] + "time_and_mem/linclust/{0}/{1}/".format(wildcards.sim_dataset, wildcards.nr_reads) )
        outfolder = config["ROOT_OUT"] + "cluster/linclust/{0}/{1}/".format(wildcards.sim_dataset, wildcards.nr_reads)
        mkdir_p(outfolder)

        linclust_output = config["ROOT_OUT"] + "cluster/linclust/{0}/{1}/linclust_out".format(wildcards.sim_dataset, wildcards.nr_reads)
        tmp_dir = config["ROOT_OUT"] + "cluster/linclust/{0}/{1}/linclust_tmpdir​".format(wildcards.sim_dataset, wildcards.nr_reads)
        shell("{time} mmseqs easy-linclust --seq-id-mode 1 --cov-mode 1 --threads 8 {input.flnc} {linclust_output} {tmp_dir} 2> {output.time_and_mem_linclust}")

        script_path = config["SCRIPT_FOLDER"]        
        shell("python {script_path}/modify_cluster_format_linclust.py {linclust_output}_cluster.tsv {output.clusters} ")


rule qt_clust_ont:
    input:  fastq = config["ROOT_OUT"] + "ont/{ont_dataset}/ont/ont.fastq"
    output: time_and_mem = config["ROOT_OUT"] + "time_and_mem/qt_clust/{ont_dataset}/ont/runtime.stdout",
            clusters = config["ROOT_OUT"] + "cluster/qt_clust/{ont_dataset}/ont/pre_clusters.csv"
    run:
        time = config["GNUTIME"]
        mkdir_p(config["ROOT_OUT"] + "time_and_mem/qt_clust/{0}/ont/".format(wildcards.ont_dataset) )
        outfolder = config["ROOT_OUT"] + "cluster/qt_clust/{0}/ont/".format(wildcards.ont_dataset)
        mkdir_p(outfolder)
        shell("{time} python /galaxy/home/ksahlin/prefix/source/isocon_nontargeted/modules/qt_clust/qt_clust.py --t 1  --fastq {input.fastq}  --outfolder {outfolder}  2>&1 | tee {output.time_and_mem}")


rule carnac_ont:
    input:  flnc_fasta = config["ROOT_OUT"] + "ont/{ont_dataset}/ont/ont.fasta"
    output: time_and_mem_carnac = config["ROOT_OUT"] + "time_and_mem/carnac_lr/{ont_dataset}/ont/runtime_carnac.stdout",
            # time_and_mem_minimap = config["ROOT_OUT"] + "time_and_mem/carnac_lr/{ont_dataset}/runtime_minimap.stdout",
            clusters = config["ROOT_OUT"] + "cluster/carnac_lr/{ont_dataset}/ont/clusters.csv"
    run:
        time = config["GNUTIME"]        
        mkdir_p(config["ROOT_OUT"] + "time_and_mem/carnac_lr/{0}/ont/".format(wildcards.ont_dataset) )
        outfolder = config["ROOT_OUT"] + "cluster/carnac_lr/{0}/ont/".format(wildcards.ont_dataset)
        mkdir_p(outfolder)
        
        minimap_out = config["ROOT_OUT"] + "cluster/carnac_lr/{0}/ont/minimap2.paf".format(wildcards.ont_dataset)
        time_and_mem_minimap = config["ROOT_OUT"] + "time_and_mem/carnac_lr/{0}/ont/runtime_minimap.stdout".format(wildcards.ont_dataset)
        shell("{time} minimap -Sw2 -L100 -t8 {input.flnc_fasta} {input.flnc_fasta} > {minimap_out} 2> {time_and_mem_minimap}")
        # shell("{time} minimap2 -t 8 -X {input.flnc_fasta} {input.flnc_fasta} > {minimap_out} 2> {time_and_mem_minimap}")

        carnac_input = config["ROOT_OUT"] + "cluster/carnac_lr/{0}/ont/carnac_in.txt​".format(wildcards.ont_dataset)
        shell("python /galaxy/home/ksahlin/prefix/source/CARNAC/scripts/paf_to_CARNAC.py {minimap_out} {input.flnc_fasta}  {carnac_input}")

        carnac_output = config["ROOT_OUT"] + "cluster/carnac_lr/{0}/ont/carnac_out.txt​".format(wildcards.ont_dataset)        
        shell("{time} CARNAC-LR -f {carnac_input} -t 8 -o {carnac_output} 2> {output.time_and_mem_carnac}")

        script_path = config["SCRIPT_FOLDER"]        
        shell("python {script_path}/carnac_modify_clusterformat.py --carnacfile {carnac_output} --flnc {input.flnc_fasta} --outfile {output.clusters} ")


rule linclust_ont:
    input:  fasta = config["ROOT_OUT"] + "ont/{ont_dataset}/ont/ont.fasta"
    output: time_and_mem_linclust = config["ROOT_OUT"] + "time_and_mem/linclust/{ont_dataset}/ont/runtime_linclust.stdout",
            clusters = config["ROOT_OUT"] + "cluster/linclust/{ont_dataset}/ont/clusters.tsv"
    run:
        time = config["GNUTIME"]
        
        mkdir_p(config["ROOT_OUT"] + "time_and_mem/linclust/{0}/ont/".format(wildcards.ont_dataset) )
        outfolder = config["ROOT_OUT"] + "cluster/linclust/{0}/ont/".format(wildcards.ont_dataset)
        mkdir_p(outfolder)

        linclust_output = config["ROOT_OUT"] + "cluster/linclust/{0}/ont/linclust_out".format(wildcards.ont_dataset)
        tmp_dir = config["ROOT_OUT"] + "cluster/linclust/{0}/ont/linclust_tmpdir​".format(wildcards.ont_dataset)
        shell("{time} mmseqs easy-linclust --seq-id-mode 1 --cov-mode 1 --threads 8 {input.fasta} {linclust_output} {tmp_dir} 2> {output.time_and_mem_linclust}")

        script_path = config["SCRIPT_FOLDER"]        
        shell("python {script_path}/modify_cluster_format_linclust.py {linclust_output}_cluster.tsv {output.clusters} ")


rule minimap2_align_ont:
    input:  reads = config["ROOT_OUT"] + "ont/{ont_dataset}/ont/ont.fastq"
    output: alignment = "/nfs/brubeck.bx.psu.edu/scratch6/ksahlin/preclust_eval/read_alignment/ont/{ont_dataset}.sam"
    
    run:
        ref = config["MMI"]
        shell("/usr/bin/time -v  minimap2 -t 8 -ax splice -uf -k14 {ref} {input.reads} >  {output.alignment} ")


rule minimap2_align_real:
    input:  reads = rules.isoseq3_real.output.flnc
    output: fastq = "/nfs/brubeck.bx.psu.edu/scratch6/ksahlin/preclust_eval/read_alignment/{dataset}.fastq",
            alignment = "/nfs/brubeck.bx.psu.edu/scratch6/ksahlin/preclust_eval/read_alignment/{dataset}.sam"
    
    run:
        shell("bamtools convert -format fastq -in {input.reads} -out {output.fastq} ")

        if wildcards.dataset in set(["Hummingbird", "Zebrafinch"]):
            ref = config[wildcards.dataset]["ref"]
            shell("/usr/bin/time -v  minimap2 -t 8 -ax splice -uf -C5 {ref} {output.fastq} >  {output.alignment} ")            
        else:
            ref = config["MMI"]
            shell("/usr/bin/time -v  minimap2 -t 8 -ax splice -uf -C5 {ref} {output.fastq} >  {output.alignment} ")

rule minimap2_align_sim:
    input:  reads = rules.simulate_dataset.output.reads,
            ref = config["MMI"]
    output: fastq = "/nfs/brubeck.bx.psu.edu/scratch6/ksahlin/preclust_eval/read_alignment/{sim_dataset}/{nr_reads}.fastq",
            alignment = "/nfs/brubeck.bx.psu.edu/scratch6/ksahlin/preclust_eval/read_alignment/{sim_dataset}/{nr_reads}.sam"
    
    run:
        shell("bamtools convert -format fastq -in {input.reads} -out {output.fastq} ")
        shell("/usr/bin/time -v  minimap2 -t 8 -ax splice -uf -C5 {input.ref} {output.fastq} >  {output.alignment} ")


rule file_convert_isoseq3_real_clusters:
    input: clusters = rules.isoseq3_real.output.clusters
    output: clusters = config["ROOT_OUT"] + "cluster/isoseq3/{dataset}/unpolished.mod_format.cluster",
    run:
        script_path = config["SCRIPT_FOLDER"]
        shell("python {script_path}/modify_cluster_format.py {input.clusters} {output.clusters} ")

rule file_convert_isoseq3_sim_clusters:
    input: clusters = rules.isoseq3_sim.output.clusters
    output: clusters = config["ROOT_OUT"] + "cluster/isoseq3/{sim_dataset}/{nr_reads}/unpolished.mod_format.cluster",
    run:
        script_path = config["SCRIPT_FOLDER"]
        shell("python {script_path}/modify_cluster_format.py {input.clusters} {output.clusters} ")


rule v_measure_ont:
    input: 
        true  = rules.minimap2_align_ont.output.alignment,
        qt_clust_predicted = rules.qt_clust_ont.output.clusters,
        carnac_predicted = rules.carnac_ont.output.clusters,
        linclust_predicted = rules.linclust_ont.output.clusters

    output: 
        qt_clust_res = config["ROOT_OUT"] + "evaluation/{ont_dataset}/ont/qt_clust_table.tsv",
        carnac_res = config["ROOT_OUT"] + "evaluation/{ont_dataset}/ont/carnac_lr_table.tsv",
        linclust_res = config["ROOT_OUT"] + "evaluation/{ont_dataset}/ont/linclust_table.tsv"
    run:
        bam = "{0}.bam".format(input.true)
        shell("samtools view -b {input.true} > {bam}")
        sorted_bam = "{0}_sorted.bam".format(input.true)
        shell("samtools sort {bam} > {sorted_bam}")
        shell("samtools index {sorted_bam}")

        script_path = config["SCRIPT_FOLDER"]
        mkdir_p(config["ROOT_OUT"] + "evaluation/{0}/ont/".format(wildcards.ont_dataset))
        shell("source activate isoseq3")
        shell("which python")
        shell("python --version")
        shell("pip list")
        shell("python {script_path}/compute_cluster_quality.py --ont --clusters {input.qt_clust_predicted} --classes {sorted_bam}  --outfile {output.qt_clust_res}")
        shell("python {script_path}/compute_cluster_quality.py --ont --clusters {input.linclust_predicted} --classes {sorted_bam}  --outfile {output.linclust_res}")
        shell("python {script_path}/compute_cluster_quality.py --ont --clusters {input.carnac_predicted} --classes {sorted_bam}  --outfile {output.carnac_res}")

        # if wildcards.ont_dataset == "Alzheimer_IsoSeq_2016":
        #     shell("touch {output.carnac_res}")
        # else:
        #     # carnac_res =config["ROOT_OUT"] + "cluster/carnac_lr/{ont_dataset}/clusters.csv"
        #     shell("python {script_path}/compute_cluster_quality.py --clusters {input.carnac_predicted} --classes {sorted_bam}  --outfile {output.carnac_res}")


rule v_measure_real:
    input: 
        true  = rules.minimap2_align_real.output.alignment,
        isoseq3_predicted  = rules.file_convert_isoseq3_real_clusters.output.clusters,
        qt_clust_predicted = rules.qt_clust_real.output.clusters,
        carnac_predicted = rules.carnac_real.output.clusters,
        linclust_predicted = rules.linclust_real.output.clusters

    output: 
        isoseq3_res = config["ROOT_OUT"] + "evaluation/{dataset}/isoseq3_table.tsv",
        qt_clust_res = config["ROOT_OUT"] + "evaluation/{dataset}/qt_clust_table.tsv",
        carnac_res = config["ROOT_OUT"] + "evaluation/{dataset}/carnac_lr_table.tsv",
        linclust_res = config["ROOT_OUT"] + "evaluation/{dataset}/linclust_table.tsv"

    run:
        bam = "{0}.bam".format(input.true)
        shell("samtools view -b {input.true} > {bam}")
        sorted_bam = "{0}_sorted.bam".format(input.true)
        shell("samtools sort {bam} > {sorted_bam}")
        shell("samtools index {sorted_bam}")

        script_path = config["SCRIPT_FOLDER"]
        mkdir_p(config["ROOT_OUT"] + "evaluation/{0}/".format(wildcards.dataset))
        shell("source activate isoseq3")
        shell("which python")
        shell("python --version")
        shell("pip list")
        shell("python {script_path}/compute_cluster_quality.py --clusters {input.isoseq3_predicted} --classes {sorted_bam}  --outfile {output.isoseq3_res}")
        shell("python {script_path}/compute_cluster_quality.py --clusters {input.qt_clust_predicted} --classes {sorted_bam}  --outfile {output.qt_clust_res}")
        shell("python {script_path}/compute_cluster_quality.py --clusters {input.linclust_predicted} --classes {sorted_bam}  --outfile {output.linclust_res}")

        if wildcards.dataset == "Alzheimer_IsoSeq_2016":
            shell("echo '-,-,-,-,-,-,-,-,-,-,-,-,-,-' >  {output.carnac_res}")
        else:
            # carnac_res =config["ROOT_OUT"] + "cluster/carnac_lr/{dataset}/clusters.csv"
            shell("python {script_path}/compute_cluster_quality.py --clusters {input.carnac_predicted} --classes {sorted_bam}  --outfile {output.carnac_res}")


rule v_measure_sim:
    input: 
        true  = rules.minimap2_align_sim.output.alignment,
        isoseq3_predicted  = rules.file_convert_isoseq3_sim_clusters.output.clusters,
        qt_clust_predicted = rules.qt_clust_sim.output.clusters,
        carnac_predicted = rules.carnac_sim.output.clusters,
        linclust_predicted = rules.linclust_sim.output.clusters

    output: 
        isoseq3_res = config["ROOT_OUT"] + "evaluation/{sim_dataset}/{nr_reads}/isoseq3_table.tsv",
        qt_clust_res = config["ROOT_OUT"] + "evaluation/{sim_dataset}/{nr_reads}/qt_clust_table.tsv",
        carnac_res = config["ROOT_OUT"] + "evaluation/{sim_dataset}/{nr_reads}/carnac_lr_table.tsv",
        linclust_res = config["ROOT_OUT"] + "evaluation/{sim_dataset}/{nr_reads}/linclust_table.tsv"

    run:
        bam = "{0}.bam".format(input.true)
        shell("samtools view -b {input.true} > {bam}")
        sorted_bam = "{0}_sorted.bam".format(input.true)
        shell("samtools sort {bam} > {sorted_bam}")
        shell("samtools index {sorted_bam}")

        script_path = config["SCRIPT_FOLDER"]
        mkdir_p(config["ROOT_OUT"] + "evaluation/{0}_{1}/".format(wildcards.sim_dataset, wildcards.nr_reads))
        shell("source activate isoseq3")
        shell("which python")
        shell("python --version")
        shell("pip list")
        shell("python {script_path}/compute_cluster_quality.py --clusters {input.isoseq3_predicted} --classes {sorted_bam}  --outfile {output.isoseq3_res}")
        shell("python {script_path}/compute_cluster_quality.py --clusters {input.qt_clust_predicted} --classes {sorted_bam}  --outfile {output.qt_clust_res}")
        shell("python {script_path}/compute_cluster_quality.py --clusters {input.carnac_predicted} --classes {sorted_bam}  --outfile {output.carnac_res}")
        shell("python {script_path}/compute_cluster_quality.py --clusters {input.linclust_predicted} --classes {sorted_bam}  --outfile {output.linclust_res}")


rule make_eval_table:
    input: real_files = expand(rules.v_measure_real.output, dataset = config["ISOSEQ_DATASET"]),
           sim_files = expand(rules.v_measure_sim.output, sim_dataset = config["SIM_DATASET"], nr_reads = config["NR_SIM_READS"]),
           ont_files = expand(rules.v_measure_ont.output, ont_dataset = config["ONT_DATASET"])
    # input: isoseq3_res = rules.v_measure_sim.output.isoseq3_res,
    #         qt_clust_res = rules.v_measure_sim.output.qt_clust_res,
    #         carnac_res = rules.v_measure_sim.output.carnac_res,
    #         linclust_res = rules.v_measure_sim.output.linclust_res,
    #         isoseq3_res = rules.v_measure_real.output.isoseq3_res,
    #         qt_clust_res = rules.v_measure_real.output.qt_clust_res,
    #         carnac_res = rules.v_measure_real.output.carnac_res,
    #         linclust_res = rules.v_measure_real.output.linclust_res
    output:
        eval_table = config["ROOT_OUT"] + "evaluation/all_datasets_eval_table.tsv"

    run:

        out_table = open(output.eval_table, 'w')
        # print(type(input.real_files), input.real_files)
        for file_name in input.real_files:
            file_ = open(file_name, "r")
            toolname = os.path.basename(file_name).split("_")[0]
            print(file_name, file_name.split("/"))
            dataset = file_name.split("/")[-2]
            line = file_.readlines()[-1]
            out_table.write("{0},{1},{2}\n".format(dataset, toolname, line.strip()))

        for file_name in input.sim_files:
            file_ = open(file_name, "r")
            toolname = os.path.basename(file_name).split("_")[0]
            print(file_name, file_name.split("/"))
            sim_dataset = file_name.split("/")[-3] + file_name.split("/")[-2]
            line = file_.readlines()[-1]
            out_table.write("{0},{1},{2}\n".format(sim_dataset, toolname, line.strip()))

        for file_name in input.ont_files:
            file_ = open(file_name, "r")
            toolname = os.path.basename(file_name).split("_")[0]
            print(file_name, file_name.split("/"))
            ont_dataset = file_name.split("/")[-2]
            line = file_.readlines()[-1]
            out_table.write("{0},{1},{2}\n".format(ont_dataset, toolname, line.strip()))

        out_table.close()



rule qt_clust_core_variability:
    input:  flnc = rules.isoseq3_real.output.flnc,
            ccs = rules.merge_demultiplexed_files.output.outfile
    output: time_and_mem = config["ROOT_OUT"] + "time_and_mem_nr_cores/qt_clust/{dataset}/{nr_cores}/runtime.stdout",
            clusters = config["ROOT_OUT"] + "cluster_nr_cores/qt_clust/{dataset}/{nr_cores}/pre_clusters.csv"
    run:
        time = config["GNUTIME"]
        mkdir_p(config["ROOT_OUT"] + "time_and_mem/qt_clust/{0}/{1}/".format(wildcards.dataset, wildcards.nr_cores) )
        outfolder = config["ROOT_OUT"] + "cluster/qt_clust/{0}/{1}/".format(wildcards.dataset, wildcards.nr_cores)

        mkdir_p(outfolder)
        shell("{time} python /galaxy/home/ksahlin/prefix/source/isocon_nontargeted/modules/qt_clust/qt_clust.py --t {wildcards.nr_cores} --flnc {input.flnc} --ccs {input.ccs}  --outfolder {outfolder}  2>&1 | tee {output.time_and_mem}")


rule v_measure_core_variability:
    input: 
        true  = rules.minimap2_align_real.output.alignment,
        qt_clust_predicted = rules.qt_clust_core_variability.output.clusters,

    output: 
        qt_clust_res = config["ROOT_OUT"] + "evaluation_nr_cores/{dataset}/{nr_cores}/qt_clust_table.tsv"
    run:
        bam = "{0}.bam".format(input.true)
        shell("samtools view -b {input.true} > {bam}")
        sorted_bam = "{0}_sorted.bam".format(input.true)
        shell("samtools sort {bam} > {sorted_bam}")
        shell("samtools index {sorted_bam}")

        script_path = config["SCRIPT_FOLDER"]
        mkdir_p(config["ROOT_OUT"] + "evaluation_nr_cores/{0}/{1}".format(wildcards.dataset, wildcards.nr_cores))
        shell("source activate isoseq3")
        shell("which python")
        shell("python --version")
        shell("pip list")
        shell("python {script_path}/compute_cluster_quality.py --clusters {input.qt_clust_predicted} --classes {sorted_bam}  --outfile {output.qt_clust_res}")


rule plot1_pb:
    input: 
        true  = rules.minimap2_align_real.output.alignment,
        qt_clust_predicted = rules.qt_clust_real.output.clusters

    output: 
        qt_clust_res = config["ROOT_OUT"] + "evaluation/{dataset}/V_per_class_size.pdf",

    run:
        bam = "{0}.bam".format(input.true)
        shell("samtools view -b {input.true} > {bam}")
        sorted_bam = "{0}_sorted.bam".format(input.true)
        shell("samtools sort {bam} > {sorted_bam}")
        shell("samtools index {sorted_bam}")

        script_path = config["SCRIPT_FOLDER"]
        shell("python {script_path}/plot_V_per_expression_bin.py --clusters {input.qt_clust_predicted}  --classes {sorted_bam} --outfile {output.qt_clust_res}")


rule plot1_sim:
    input: 
        true  = rules.minimap2_align_sim.output.alignment,
        qt_clust_predicted = rules.qt_clust_sim.output.clusters,

    output: 
        qt_clust_res = config["ROOT_OUT"] + "evaluation/{sim_dataset}/{nr_reads}/V_per_class_size.pdf"
    run:
        bam = "{0}.bam".format(input.true)
        shell("samtools view -b {input.true} > {bam}")
        sorted_bam = "{0}_sorted.bam".format(input.true)
        shell("samtools sort {bam} > {sorted_bam}")
        shell("samtools index {sorted_bam}")

        script_path = config["SCRIPT_FOLDER"]
        shell("python {script_path}/plot_V_per_expression_bin.py --clusters {input.qt_clust_predicted}  --classes {sorted_bam} --outfile {output.qt_clust_res}")


rule plot1_ont:
    input: 
        true  = rules.minimap2_align_ont.output.alignment,
        qt_clust_predicted = rules.qt_clust_ont.output.clusters
    output: 
        qt_clust_res = config["ROOT_OUT"] + "evaluation/{ont_dataset}/ont/V_per_class_size.pdf",

    run:
        bam = "{0}.bam".format(input.true)
        shell("samtools view -b {input.true} > {bam}")
        sorted_bam = "{0}_sorted.bam".format(input.true)
        shell("samtools sort {bam} > {sorted_bam}")
        shell("samtools index {sorted_bam}")

        script_path = config["SCRIPT_FOLDER"]
        shell("python {script_path}/plot_V_per_expression_bin.py --ont --clusters {input.qt_clust_predicted}  --classes {sorted_bam} --outfile {output.qt_clust_res}")



